# Coeficiente de Assimetria (Skew)
for(i in 1:ncol(aed.trn)){
if(is.numeric(aed.trn[,i])){
ca <- skewness(aed.trn[,i])
print(ca)
}
}
# Coeficiente de Curtose
for(i in 1:ncol(aed.trn)){
if(is.numeric(aed.trn[,i])){
ck <- kurtosis(aed.trn[,i])
print(ck)
}
}
par(mfrow=c(1,2))
for(i in var.fct[-1]){
CrossTable(aed.trn$class,
aed.trn[,i],
prop.t = T,
chisq = T,
digits = 2,
dnn = c("class", i))
}
# Diagramas de Dispersão - Matriz de Correlação
plot(aed.trn[])
# Tabela dos Coeficientes de Correlação
cor(aed.trn[var.num])
# Gráfico dos Coeficientes de Correlação
cor.plot(aed.trn[,c(var.num, var.num_con)])
# Boxplots Idade conforme as Categóricas
par(mfrow=c(1,3), cex = 0.65)
for(i in var.fct){
boxplot(aed.trn$Age ~ aed.trn[,i], beside = TRUE, xlab = names(aed.trn)[grep(i, names(aed.trn))])
}
# Boxplots Numéricas conforme as Survived
# par(mfrow=c(2,2))
for(i in 0:length(aed.trn)){
if(is.numeric(aed.trn[,i])){
boxplot(aed.trn[,i] ~ class, ylab = names(aed.trn)[i], data = aed.trn)
}
}
dput(aed.trn, file = "datasets/aed_trn.R")
#massa <- z.trn
#mdl.tst <- z.tst
massa <- aed.trn
mdl.tst <- etl.tst
# Configurando uma semente para que o Gerador Aleatório de Números seja reproduzível.
set.seed(1618)
# Criando uma coluna com índices randômicos.
massa[ ,'index'] <- ifelse(runif(nrow(massa)) < 0.8, 1, 0)
# Criando os conjuntos de treino e de validação.
mdl.trn <- massa[massa$index == 1, ]
mdl.vld <- massa[massa$index == 0, ]
# Obtem o índice (posição), no vetor de nomes, onde corresponde ao valor 'index'.
col_idx <- grep('index', names(mdl.trn))
# Remove a coluna 'index' dos datasets, utilizando a posição obtida.
mdl.trn <- mdl.trn[ , -col_idx]
mdl.vld <- mdl.vld[ , -col_idx]
# Gerar Modelos de Classificação
ajt.trn <- glm(formula = class ~ .,
family = binomial(link = "logit"),
data = mdl.trn)
summary(ajt.trn)
pred <- predict( ajt.trn,
newdata = mdl.vld,
type = "response" )
# Criando um dataframe com os dados observados e os preditos.
previsoes <- data.frame(observado = mdl.vld$Survived,
previsto = pred %>%
round() %>%
factor(labels = c("Não", "Sim")))
pred <- predict( ajt.trn,
newdata = mdl.vld,
type = "response" )
# Criando um dataframe com os dados observados e os preditos.
previsoes <- data.frame(observado = mdl.vld$class,
previsto = pred %>%
round() %>%
factor(labels = c("Não", "Sim")))
CrossTable(previsoes$observado,
previsoes$previsto)
chisq.test(previsoes$observado,
previsoes$previsto)
hist(pred,
xlab = "Predições",
main = "Histograma de Predições")
cm <- confusionMatrix(previsoes$observado,
previsoes$previsto,
positive = "Sim")
pred <- predict( ajt.trn,
newdata = mdl.vld,
type = "response" )
# Criando um dataframe com os dados observados e os preditos.
previsoes <- data.frame(observado = mdl.vld$class,
previsto = pred %>%
round() %>%
factor(labels = c("Não", "Sim")))
CrossTable(previsoes$observado,
previsoes$previsto)
pred <- predict( ajt.trn,
newdata = mdl.vld,
type = "response" )
# Criando um dataframe com os dados observados e os preditos.
previsoes <- data.frame(observado = mdl.vld$class,
previsto = pred %>%
round() %>%
factor(labels = c("Sim", "Não")))
CrossTable(previsoes$observado,
previsoes$previsto)
chisq.test(previsoes$observado,
previsoes$previsto)
hist(pred,
xlab = "Predições",
main = "Histograma de Predições")
cm <- confusionMatrix(previsoes$observado,
previsoes$previsto,
positive = "Sim")
print(cm)
fourfoldplot(cm$table)
mosaicplot(cm$table, color = TRUE, shade = TRUE, main = "Mosaico para Confusion Matrix", )
acuracia <- (cm$table[1,1] + cm$table[2,2])/(cm$table[1,1] + cm$table[1,2] + cm$table[2,1] + cm$table[2,2])
# Precision
precisao <- cm$table[1,1] / (cm$table[1,1] + cm$table[1,2])
sensibilidade <- cm$table[1,1] / (cm$table[1,1] + cm$table[2,1])
f1 <- (2 * sensibilidade * precisao) / (sensibilidade + precisao)
metricas <- kable(
data.frame(
"Acuracia" = acuracia,
"Precisao" = precisao,
"Sensibilidade" = sensibilidade,
"F1-Score" = f1), format = "markdown", align = 'l')
metricas
class1 <- predict(ajt.trn, newdata = mdl.vld, type = "response")
class2 <- mdl.vld$Survived
pred <- prediction(class1, class2)
class1 <- predict(ajt.trn, newdata = mdl.vld, type = "response")
class2 <- mdl.vld$class
pred <- prediction(class1, class2)
perf <- performance(pred, "tpr", "fpr")
# Gerando uma curva ROC em R
plot(perf, col = rainbow(10, alpha = NULL))
chisq.test(previsoes$observado, previsoes$previsto)
predict(ajt.trn,
newdata = mdl.tst,
type = "response") %>%
round() %>%
factor(labels = c("Não", "Sim")) -> predicao
CrossTable(predicao, prop.t = T, digits = 2)
str(diabetes) # Estrutura do dataset
str(etl.full) # Estrutura do dataset
library("Amelia", lib.loc="C:/Users/ulp/anaconda3/envs/rstudio/lib/R/library")
detach("package:Amelia", unload=TRUE)
install.packages("Amelia")
library("Amelia", lib.loc="C:/Users/ulp/anaconda3/envs/rstudio/lib/R/library")
install.packages("Amelia")
missmap(etl.full)
Amelia(etl.full)
amelia(etl.full)
Amelia::(etl.full)
library("Amelia", lib.loc="C:/Users/ulp/anaconda3/envs/rstudio/lib/R/library")
detach("package:Amelia", unload=TRUE)
library("Amelia", lib.loc="C:/Users/ulp/anaconda3/envs/rstudio/lib/R/library")
knitr::opts_chunk$set(  echo=TRUE )
# , message=FALSE
# , warning=FALSE
# , include=TRUE)
options(OutDec = ",")
source(file = "scripts/set_wd.R")
getwd()
source(file = "scripts/packages_require.R")
source(file = "scripts/functions.R")
source(file = "scripts/ds_load.R")
# TREINO: Pré-visualização das primeiras observações:
etl.full %>%
head() %>%
tibble(format = "markdown", caption = "Primeiras observações")
print(etl.full)
dim(etl.full) # Dimensões do dataset
str(etl.full) # Estrutura do dataset
# Soma de valores missing por variável em Treino
if(any(is.na(etl.full)))
{
subset(data.frame("SubTotal_NA" = apply(etl.full,
2,
function(x){
sum(is.na(x))
})), SubTotal_NA > 0)
}
# Variável 'class'
etl.full$class <- factor(etl.full$class, labels = c(Positive = "Positivo", Negative = "Negativo"))
# Variável 'Gender'
etl.full$Gender <- factor(etl.full$Gender, labels = c(Male = "Homem", Female = "Mulher"))
# Variável 'Polyuria'
etl.full$Polyuria <- factor(etl.full$Polyuria, labels = c(No = "Não", Yes = "Sim"))
# Variável 'Polydipsia'
etl.full$Polydipsia <- factor(etl.full$Polydipsia, labels = c(No = "Não", Yes = "Sim"))
# Variável 'sudden.weight.loss'
etl.full$sudden.weight.loss <- factor(etl.full$sudden.weight.loss, labels = c(No = "Não", Yes = "Sim"))
# Variável 'weakness'
etl.full$weakness <- factor(etl.full$weakness, labels = c(No = "Não", Yes = "Sim"))
# Variável 'Polyphagia'
etl.full$Polyphagia <- factor(etl.full$Polyphagia, labels = c(No = "Não", Yes = "Sim"))
# Variável 'Genital.thrush'
etl.full$Genital.thrush <- factor(etl.full$Genital.thrush, labels = c(No = "Não", Yes = "Sim"))
# Variável 'visual.blurring'
etl.full$visual.blurring <- factor(etl.full$visual.blurring, labels = c(No = "Não", Yes = "Sim"))
# Variável 'Itching'
etl.full$Itching <- factor(etl.full$Itching, labels = c(No = "Não", Yes = "Sim"))
# Variável 'Irritability'
etl.full$Irritability <- factor(etl.full$Irritability, labels = c(No = "Não", Yes = "Sim"))
# Variável 'delayed.healing'
etl.full$delayed.healing <- factor(etl.full$delayed.healing, labels = c(No = "Não", Yes = "Sim"))
# Variável 'partial.paresis'
etl.full$partial.paresis <- factor(etl.full$partial.paresis, labels = c(No = "Não", Yes = "Sim"))
# Variável 'muscle.stiffness'
etl.full$muscle.stiffness <- factor(etl.full$muscle.stiffness, labels = c(No = "Não", Yes = "Sim"))
# Variável 'Alopecia'
etl.full$Alopecia <- factor(etl.full$Alopecia, labels = c(No = "Não", Yes = "Sim"))
# Variável 'Obesity'
etl.full$Obesity <- factor(etl.full$Obesity, labels = c(No = "Não", Yes = "Sim"))
str(diabetes) # Estrutura do dataset
str(etl.full) # Estrutura do dataset
# Dividindo os dados em treino e teste, 70% para dados de treino e 30% para dados de teste
set.seed(7)
rows <- sample(1:nrow(etl.full), 0.7 * nrow(etl.full))
etl.trn <- etl.full[rows,]
etl.tst <- etl.full[-rows,]
# write.csv(treino.etl, "../datasets/treino_etl.csv", row.names = FALSE)
dput(etl.trn, file = "datasets/etl_trn.R")
dput(etl.tst, file = "datasets/etl_tst.R")
dput(etl.full, file = "datasets/etl_full.R")
aed.trn <- dget(file = "datasets/etl_trn.R")
# Qualitativas Nominais
var.fct <- c()
for(i in 1:ncol(aed.trn)){
if(is.factor(aed.trn[,i]) && !is.ordered(aed.trn[,i]))
{
var.fct = c(var.fct, names(aed.trn)[i])
}
}
# Qualitativas Ordinais
var.fct_ord <- c()
for(i in 1:ncol(aed.trn)){
i = 1
if(is.factor(aed.trn[,i]) && is.ordered(aed.trn[,i]))
{
var.fct_ord = c(var.fct_ord, names(aed.trn)[i])
}
}
# Quantitativas Discretas
var.num <- c()
for(i in 1:ncol(aed.trn)){
if(is.integer(aed.trn[,i]))
{
var.num <- c(var.num, names(aed.trn)[i])
}
}
# Quantitativas Contínuas
var.num_con <- c()
for(i in 1:ncol(aed.trn)){
if(typeof(aed.trn[,i]) == "double")
{
var.num_con <- c(var.num_con, names(aed.trn)[i])
}
}
data.frame("Qualitativas_Nominais - " = var.fct)
data.frame("Qualitativas_Ordinais - " = var.fct_ord)
data.frame("Quantitativas_Discretas - " = var.num)
data.frame("Quantitativas_Contínuas - " = var.num_con)
describe(aed.trn )
# Distribuição de Frequências para as Variáveis Qualitativas Nominais
for(i in var.fct){
fdt_cat(aed.trn[,i]) %>%
tibble() -> df
names(df)[1] = c(colnames(aed.trn[i]))
print(kable(df[order(df[2], decreasing = TRUE),]))
}
# Distribuição de Frequências para as Variáveis Qualitativas Ordinais
for(i in var.fct_ord){
fdt_cat(aed.trn[,i]) %>%
tibble() -> df
names(df)[1] = c(colnames(aed.trn[i]))
print(kable(df[order(df[2], decreasing = TRUE),]))
}
# Gráficos de barras para variáveis categóricas
par(mfrow=c(2,2), cex = 0.55)
for(i in c(var.fct, var.fct_ord)){
bp <- barplot(table(aed.trn[i]),
main = names(aed.trn[i]),
ylim = c(0, max(table(aed.trn[i]))*1.4),
col = "green")
text(x = as.vector(bp),
y = table(aed.trn[,i]) + 2,
label =  round(table(aed.trn[i]), 1),
pos = 3,
col = "black")
}
par(mfrow=c(2,1))
# Distribuição de Frequências: Variáveis Quantitativas
for(i in var.num){
df <- fdt(aed.trn[,i])
#names(df)[[1]] = c(colnames(aed.trn[i]))
print(kable(df, caption = "Title of the table"))
}
par(mfrow=c(1,1))
# Gráfico de Dispersão Unidimensional: Variáveis Quantitativas
for(i in 1:ncol(aed.trn)){
if(is.numeric(aed.trn[,i])){
dotchart(aed.trn[,i], main = paste("Dispersão Unidimensional:", names(aed.trn)[i]))
}
}
# Gráfico Ramo e Folhas: Variáveis Quantitativas
for(i in 1:ncol(aed.trn)){
if(is.numeric(aed.trn[,i])){
stem(aed.trn[,i])
}
}
# Gráfico Histograma: Varáveis Quantitativas
# par(mfrow=c(1,2))
for(i in 1:ncol(aed.trn)){
if(is.numeric(aed.trn[,i])){
hist(aed.trn[,i],
main = paste("Histograma\n", names(aed.trn)[i]),
xlab = names(aed.trn)[i],
#ylim = c(0, max(table(aed.trn[,"Age"]))*2.5),
labels = TRUE,
nclass = round(1+3.22*log10(nrow(as.array(aed.trn[,i])))) )
}
}
stargazer(aed.trn, median = T, mean.sd = T, iqr = T, type = "text", title = "Sumário Estatístico")
n = c()
m = c()
# Moda
for(i in 1:ncol(aed.trn)){
if(is.factor(aed.trn[,i])){
n = c(n, names(aed.trn)[i])
m = c(m, moda(aed.trn[,i]))
}
}
kable(data.frame("Variável" = n, "Moda" = m), align = "l")
# Quartis
# par(mfrow=c(2,2))
#df <- data.frame()
for(i in 1:ncol(aed.trn)){
if(is.numeric(aed.trn[,i])){
q <- data.frame(
quantile(aed.trn[,i])
)
names(q)[length(q)] <- names(aed.trn)[i]
print(q)
}
}
# Quintis
par(mfrow=c(2,2))
for(i in 1:ncol(aed.trn)){
if(is.numeric(aed.trn[,i])){
quintis = seq(.2, .8, .2)
q <- data.frame(quantile(aed.trn[,i], quintis))
names(q) <- names(aed.trn)[i]
print(q)
}
}
# Decis
for(i in 1:ncol(aed.trn)){
if(is.numeric(aed.trn[,i])){
decis = seq(.1, .9, .1)
q <- data.frame(quantile(aed.trn[,i], decis))
names(q) <- names(aed.trn)[i]
print(q)
}
}
# Percentis
par(mfrow=c(2,2))
for(i in 1:ncol(aed.trn)){
if(is.numeric(aed.trn[,i])){
percentis = seq(.01, .99, .01)
q <- data.frame(quantile(aed.trn[,i], percentis))
names(q) <- names(aed.trn)[i]
print(q)
}
}
# Boxplot
# par(mfrow=c(2,2))
aed.trn$previsao = NULL
aed.trn$index = NULL
for(i in 1:ncol(aed.trn)){
if(is.numeric(aed.trn[,i])){
boxplot(summary(aed.trn[,i]),
ylab = names(aed.trn)[i],
main = paste("Boxplot", names(aed.trn)[i]))
}
}
# Amplitude Total
for(i in 1:ncol(aed.trn)){
if(is.numeric(aed.trn[,i])){
amp <- diff(range(aed.trn[,i]))
print(amp)
}
}
# Variância
for(i in 1:ncol(aed.trn)){
if(is.numeric(aed.trn[,i])){
print(
var(aed.trn[,i])
)
}
}
# Desvio Padrão
for(i in 1:ncol(aed.trn)){
if(is.numeric(aed.trn[,i])){
print(
sd(aed.trn[,i])
)
}
}
# Coeficiente de Variação
for(i in 1:ncol(aed.trn)){
if(is.numeric(aed.trn[,i])){
cv <- 100*sd(aed.trn[,i]/mean(aed.trn[,i]))
print(cv)
}
}
#par(mfrow=c(2,2))
for(i in 1:ncol(aed.trn)){
if(is.numeric(aed.trn[,i])){
datasim <- data.frame(aed.trn[,i])
g <- ggplot(datasim, aes(x = aed.trn[,i]), binwidth = 2) +
geom_histogram(aes(y = ..density..), fill = 'red', alpha = 0.5) +
geom_density(colour = 'blue') + xlab(expression(bold('Dados'))) +
ylab(expression(bold('Densidade')))
print(g)
}
}
# Coeficiente de Assimetria (Skew)
for(i in 1:ncol(aed.trn)){
if(is.numeric(aed.trn[,i])){
ca <- skewness(aed.trn[,i])
print(ca)
}
}
# Coeficiente de Curtose
for(i in 1:ncol(aed.trn)){
if(is.numeric(aed.trn[,i])){
ck <- kurtosis(aed.trn[,i])
print(ck)
}
}
par(mfrow=c(1,2))
for(i in var.fct[-1]){
CrossTable(aed.trn$class,
aed.trn[,i],
prop.t = T,
chisq = T,
digits = 2,
dnn = c("class", i))
}
# Diagramas de Dispersão - Matriz de Correlação
plot(aed.trn[])
# Tabela dos Coeficientes de Correlação
cor(aed.trn[var.num])
# Boxplots Idade conforme as Categóricas
par(mfrow=c(1,3), cex = 0.65)
for(i in var.fct){
boxplot(aed.trn$Age ~ aed.trn[,i], beside = TRUE, xlab = names(aed.trn)[grep(i, names(aed.trn))])
}
# Boxplots Numéricas conforme as Survived
# par(mfrow=c(2,2))
for(i in 0:length(aed.trn)){
if(is.numeric(aed.trn[,i])){
boxplot(aed.trn[,i] ~ class, ylab = names(aed.trn)[i], data = aed.trn)
}
}
dput(aed.trn, file = "datasets/aed_trn.R")
#massa <- z.trn
#mdl.tst <- z.tst
massa <- aed.trn
mdl.tst <- etl.tst
# Configurando uma semente para que o Gerador Aleatório de Números seja reproduzível.
set.seed(1618)
# Criando uma coluna com índices randômicos.
massa[ ,'index'] <- ifelse(runif(nrow(massa)) < 0.8, 1, 0)
# Criando os conjuntos de treino e de validação.
mdl.trn <- massa[massa$index == 1, ]
mdl.vld <- massa[massa$index == 0, ]
# Obtem o índice (posição), no vetor de nomes, onde corresponde ao valor 'index'.
col_idx <- grep('index', names(mdl.trn))
# Remove a coluna 'index' dos datasets, utilizando a posição obtida.
mdl.trn <- mdl.trn[ , -col_idx]
mdl.vld <- mdl.vld[ , -col_idx]
# Gerar Modelos de Classificação
ajt.trn <- glm(formula = class ~ .,
family = binomial(link = "logit"),
data = mdl.trn)
summary(ajt.trn)
pred <- predict( ajt.trn,
newdata = mdl.vld,
type = "response" )
# Criando um dataframe com os dados observados e os preditos.
previsoes <- data.frame(observado = mdl.vld$class,
previsto = pred %>%
round() %>%
factor(labels = c("Sim", "Não")))
CrossTable(previsoes$observado,
previsoes$previsto)
chisq.test(previsoes$observado,
previsoes$previsto)
hist(pred,
xlab = "Predições",
main = "Histograma de Predições")
cm <- confusionMatrix(previsoes$observado,
previsoes$previsto,
positive = "Sim")
